import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.interpolate import interp1d

# Constants
mu_0 = 4 * np.pi * 1e-7
mu_r = 1.0997785                                         # From Maxwell's material property
Ms = 1e6                                                 # A/m, Magnitude of Magnetization
eps = 1e-12                                              # small value to avoid singularities

# Magnetization vector (A/m) - X-DIRECTION

Ms_vec = np.array([1, 0, 0])

# Magnet dimensions (FIXED position in global coordinates, centered at origin)
# This assumes the bar magnet in Maxwell is fixed from X=-10mm to X=10mm, Y=-2mm to Y=2mm, Z=-1mm to Z=1mm.
x1_magnet_fixed = 10e-3                                  # -10 mm 
x2_magnet_fixed = 30e-3                                  # 10 mm
y1_magnet_fixed = 0e-3                                   # -2 mm
y2_magnet_fixed = 4e-3                                   # 2 mm
z1_magnet_fixed = 0e-3                                   # -1 mm
z2_magnet_fixed = 2e-3                                   # 1 mm


# Observation points (SWEEPING along X)
# The X-axis in your Maxwell plots goes from 0 to 40mm.
x_obs_scan = np.linspace(0e-3, 40e-3, 1000)              # Varying X since line can also be -20 to 20 
# Fixed Y and Z for the observation line 
fixed_y_obs = 2e-3                                       # Middle of Width i.e Y 
fixed_z_obs = 3e-3                                       # 1mm above the surface i.e Z 

##########################################################################
####################### Helper functions #################################
##########################################################################

def G_func(x, y, z, x_n, y_m, z_k):
    return 1.0 / (np.sqrt((x - x_n)**2 + (y - y_m)**2 + (z - z_k)**2) + eps)

def H_func(x, y, z, x1, x2, y_m, z_k):
    R1 = np.sqrt((x - x1)**2 + (y - y_m)**2 + (z - z_k)**2)
    R2 = np.sqrt((x - x2)**2 + (y - y_m)**2 + (z - z_k)**2)
    num = (x - x1) + R1
    den = (x - x2) + R2 + eps
    return num / den

def F_func(x, y, z, x_n, y1, y2, z_k):
    R1 = np.sqrt((x - x_n)**2 + (y - y1)**2 + (z - z_k)**2)
    R2 = np.sqrt((x - x_n)**2 + (y - y2)**2 + (z - z_k)**2)
    num = (y - y1) + R1
    den = (y - y2) + R2 + eps
    return num / den

def compute_B_field_at_obs(x_obs, y_obs, z_obs, x1_m, x2_m, y1_m, y2_m, z1_m, z2_m, Ms_magnitude, Ms_direction_vec, mu_r_val):
    # Initialize B components
    Bx_comp = 0.0                                        # Bx component from analytical formula
    By_comp = 0.0                                        # By component from analytical formula
    Bz_comp = 0.0                                        # Bz component from analytical formula
    
    # Bx formula contribution 
    for k, z_k in enumerate([z1_m, z2_m]):
        for n, x_n in enumerate([x1_m, x2_m]):
            for m, y_m in enumerate([y1_m, y2_m]):
                sign = (-1)**(k + n + m)
                g = G_func(x_obs, y_obs, z_obs, x_n, y_m, z_k)
                arctan_arg = ((y_obs - y_m) * (z_obs - z_k)) / ((x_obs - x_n) + eps) * g
                Bx_comp += sign * np.arctan(arctan_arg)
    # Apply Ms_magnitude and the X-component of Ms_vec
    Bx_total = Bx_comp * (mu_0 * Ms_magnitude * Ms_direction_vec[0] * mu_r_val) / (4 * np.pi)

                
    # By formula contribution (was previously linked to Ms_vec[1])
    for k, z_k in enumerate([z1_m, z2_m]):
        for m, y_m in enumerate([y1_m, y2_m]):
            sign = (-1)**(k + m)
            H = H_func(x_obs, y_obs, z_obs, x1_m, x2_m, y_m, z_k)
            By_comp += sign * np.log(H)
    # Apply Ms_magnitude and the Y-component of Ms_vec
    By_total = By_comp * (mu_0 * Ms_magnitude * Ms_direction_vec[1] * mu_r_val) / (4 * np.pi)
    
    
    # Bz formula contribution 
    for k, z_k in enumerate([z1_m, z2_m]):
        for n, x_n in enumerate([x1_m, x2_m]):
            sign = (-1)**(k + n)
            F = F_func(x_obs, y_obs, z_obs, x_n, y1_m, y2_m, z_k)
            Bx_comp += sign * np.log(F)
    # Apply Ms_magnitude and the Z-component of Ms_vec
    Bz_total = Bz_comp * (mu_0 * Ms_magnitude * Ms_direction_vec[2] * mu_r_val) / (4 * np.pi)

    return Bx_total, By_total, Bz_total

##############################################################################################    
################################--- Main computation ---######################################
##############################################################################################

Bx_vals, By_vals, Bz_vals, Bmag_vals = [], [], [], []

# Loop through each x_obs_position while magnet is FIXED
for x_obs_pt in x_obs_scan:
    Bx, By, Bz = compute_B_field_at_obs(x_obs_pt, fixed_y_obs, fixed_z_obs,
                                        x1_magnet_fixed, x2_magnet_fixed,
                                        y1_magnet_fixed, y2_magnet_fixed,
                                        z1_magnet_fixed, z2_magnet_fixed,
                                        Ms, Ms_vec, mu_r)
    Bmag = np.sqrt(Bx**2 + By**2 + Bz**2)
    Bx_vals.append(Bx)
    By_vals.append(By)
    Bz_vals.append(Bz)
    Bmag_vals.append(Bmag)

# Convert for plotting
x_mm = x_obs_scan * 1e3
Bx_vals = np.array(Bx_vals)
By_vals = np.array(By_vals)
Bz_vals = np.array(Bz_vals)
Bmag_vals = np.array(Bmag_vals)

max_idx = np.argmax(Bmag_vals)
print(f"\nMagnet Fixed at: X=[{x1_magnet_fixed*1e3:.1f}, {x2_magnet_fixed*1e3:.1f}] mm, Y=[{y1_magnet_fixed*1e3:.1f}, {y2_magnet_fixed*1e3:.1f}] mm, Z=[{z1_magnet_fixed*1e3:.1f}, {z2_magnet_fixed*1e3:.1f}] mm")
print(f"Observation Line: Y={fixed_y_obs*1e3:.1f} mm, Z={fixed_z_obs*1e3:.1f} mm, X-scan from {x_mm.min():.1f} to {x_mm.max():.1f} mm")
print(f"Max |B| = {Bmag_vals[max_idx]:.6f} T at x = {x_mm[max_idx]:.6f} mm")
print(f"  --> Bx = {Bx_vals[max_idx]:.6f} T")
print(f"  --> By = {By_vals[max_idx]:.6f} T")
print(f"  --> Bz = {Bz_vals[max_idx]:.6f} T")

# Plotting
plt.figure(figsize=(12, 7))
plt.plot(x_mm, Bx_vals, label='Bx (Analytical)', color='red')
#plt.plot(x_mm, By_vals, label='By (Analytical)', color='green')
#plt.plot(x_mm, Bz_vals, label='Bz (Analytical)', color='blue')
plt.plot(x_mm, Bmag_vals, label='|B| (Analytical)', linestyle='--', color='purple')

plt.xlabel('Observation X Position (mm)')
plt.ylabel('Magnetic Field (T)')
plt.title('Analytical Magnetic Field Components vs. Observation Position (X-Magnetization Only)')
plt.grid(True, linestyle='--', alpha=0.7)
plt.legend()
plt.axvline(x1_magnet_fixed * 1000, color='gray', linestyle=':', label='Magnet X-start')
plt.axvline(x2_magnet_fixed * 1000, color='gray', linestyle=':', label='Magnet X-end')
plt.tight_layout()
plt.show()

################################
# --- Step 1: Load CSV Data from Maxwell ---
# Load data
df_bx = pd.read_excel(r'C:\Users\VASAMPAM\OneDrive - Schaeffler\Desktop\Bar_Bx_one.xlsx')

print("Bx columns:", df_bx.columns)

df_bx

# Assuming the CSV has headers like "x_mm" and "Bx_T"
# Replace these with actual column names if different
x_sim = df_bx.iloc[:, 0].values  # X in mm
Bx_sim = df_bx.iloc[:, 1].values  # Bx in Tesla

# --- Step 2: Interpolate analytical data to match simulation x points ---
# Ensure x_mm and Bx_vals are already defined above
interp_analytical = interp1d(x_mm, Bx_vals, kind='linear', bounds_error=False, fill_value="extrapolate")
Bx_analytical_interp = interp_analytical(x_sim)

# --- Step 3: Compute percentage error ---
percent_error = 100 * np.abs((Bx_sim - Bx_analytical_interp) / (np.abs(Bx_sim) + 1e-12))  # Avoid division by zero
#relative_error = np.abs((Bx_sim - Bx_analytical_interp) / (np.abs(Bx_sim) + 1e-12))  # Avoid division by zero

# --- Step 4: Plot Comparison ---
plt.figure(figsize=(12, 6))
plt.plot(x_sim, Bx_sim, label='Bx (Maxwell)', color='blue')
plt.plot(x_sim, Bx_analytical_interp, label='Bx (Analytical)', color='red', linestyle='--')
plt.xlabel('X Position (mm)')
plt.ylabel('Bx (Tesla)')
plt.title('Validation of Bx: Analytical vs Maxwell')
plt.grid(True, linestyle='--')
plt.legend()
plt.tight_layout()
plt.show()

# --- Step 5: Plot Percentage Error ---
plt.figure(figsize=(10, 4))
plt.plot(x_sim, percent_error, label='Percentage Error', color='purple')
plt.xlabel('X Position (mm)')
plt.ylabel('Error (%)')
plt.title('Percentage Error between Analytical and Maxwell Bx')
plt.grid(True, linestyle='--')
plt.legend()
plt.tight_layout()
plt.show()

# --- Optional: Report maximum error ---
max_error = np.max(percent_error)
max_error_index = np.argmax(percent_error)
print(f"Maximum Percentage Error: {max_error:.2f}% at x = {x_sim[max_error_index]:.2f} mm")







